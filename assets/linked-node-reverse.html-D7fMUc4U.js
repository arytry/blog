import{_ as s,c as n,o as a,e}from"./app-0TPXc-ei.js";const p="/assets/img/algorithms/linked-node-reverse-1.jpg",t="/assets/img/algorithms/linked-node-reverse-2.jpg",l="/assets/img/algorithms/linked-node-reverse-3.jpg",c="/assets/img/algorithms/linked-node-reverse-4.jpg",i={},o=e('<h1 id="链表反转" tabindex="-1"><a class="header-anchor" href="#链表反转"><span>链表反转</span></a></h1><h2 id="单链表" tabindex="-1"><a class="header-anchor" href="#单链表"><span>单链表</span></a></h2><p>很多公司的面试题库中都有这道题，有的公司明确题目要求不能使用额外的节点存储空间，有的没有明确说明，但是如果面试者使用了额外的节点存储空间做中转，会得到一个比较低的分数。如何在不使用额外存储节点的情况下使一个单链表的所有节点逆序？我们先用迭代循环的思想来分析这个问题，链表的初始状态如图所示：</p><p><img src="'+p+'" alt="初始状态" title="初始状态"></p><p>初始状态，prev是NULL，head指向当前的头节点A，next指向A节点的下一个节点B。首先从A节点开始逆序，将A节点的next指针指向prev，因为prev的当前值是NULL，所以A节点就从链表中脱离出来了，然后移动head和next指针，使它们分别指向B节点和B的下一个节点C（因为当前的next已经指向B节点了，因此修改A节点的next指针不会导致链表丢失）。逆向节点A之后，链表的状态如图所示：</p><p><img src="'+t+`" alt="第一次迭代" title="第一次迭代"></p><p>从初始状态到第一次迭代状态共做了四个操作，这四个操作的伪代码如下：</p><div class="language-c# line-numbers-mode" data-highlighter="prismjs" data-ext="c#" data-title="c#"><pre class="language-c#"><code><span class="line">head.next = prev;</span>
<span class="line">prev = head;</span>
<span class="line">head = next;</span>
<span class="line">next = next.next;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这四行伪代码就是循环算法的迭代体了，现在用这个迭代体对第一次迭代的状态再进行一轮迭代，就得到了如下的状态：</p><p><img src="`+l+'" alt="第二次迭代" title="第二次迭代"></p><p>那么循环终止条件呢？现在对第二次迭代的状态再迭代一次得到如下的状态：</p><p><img src="'+c+`" alt="第三次迭代" title="第三次迭代"></p><p>此时可以看出，在第三次迭代的基础上再进行一次迭代就可以完成链表的逆序，因此循环迭代的终止条件就是当前的head指针是NULL。</p><p>现在来总结一下，循环的初始条件是：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="line">prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>循环迭代体是：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="line">head<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span></span>
<span class="line">prev <span class="token operator">=</span> head<span class="token punctuation">;</span></span>
<span class="line">head <span class="token operator">=</span> next<span class="token punctuation">;</span></span>
<span class="line">next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>循环终止条件是：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="line">head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>根据以上分析结果，逆序单链表的循环算法如下所示：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="line"><span class="token doc-comment comment">/// <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>summary</span><span class="token punctuation">&gt;</span></span></span></span>
<span class="line"><span class="token doc-comment comment">/// 定义一个链表结构体</span></span>
<span class="line"><span class="token doc-comment comment">/// <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>summary</span><span class="token punctuation">&gt;</span></span></span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Node</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> Id <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token return-type class-name">Node</span> Next <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token doc-comment comment">/// <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>summary</span><span class="token punctuation">&gt;</span></span></span></span>
<span class="line"><span class="token doc-comment comment">/// 链表结构逆序算法</span></span>
<span class="line"><span class="token doc-comment comment">/// <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>summary</span><span class="token punctuation">&gt;</span></span></span></span>
<span class="line"><span class="token doc-comment comment">/// <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>head<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param</span><span class="token punctuation">&gt;</span></span></span></span>
<span class="line"><span class="token return-type class-name">Node</span> <span class="token function">Reverse</span><span class="token punctuation">(</span><span class="token class-name">Node</span> head<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name">Node</span> prev <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name"><span class="token keyword">var</span></span> next <span class="token operator">=</span> head<span class="token punctuation">.</span>Next<span class="token punctuation">;</span></span>
<span class="line">        <span class="token comment">//改变head的next节点</span></span>
<span class="line">        head<span class="token punctuation">.</span>Next <span class="token operator">=</span> prev<span class="token punctuation">;</span></span>
<span class="line">        prev <span class="token operator">=</span> head<span class="token punctuation">;</span></span>
<span class="line">        head <span class="token operator">=</span> next<span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">总结</p><p>需要三个变量才能保证迭代后的所有信息不会丢失，通过图片其实已经能够很好的理解到原理</p></div><h2 id="相关链接" tabindex="-1"><a class="header-anchor" href="#相关链接"><span>相关链接</span></a></h2><p><a href="https://blog.csdn.net/autumn20080101/article/details/7607148" title="单链表逆序" target="_blank" rel="noopener noreferrer">单链表逆序</a></p>`,24),r=[o];function d(u,m){return a(),n("div",null,r)}const v=s(i,[["render",d],["__file","linked-node-reverse.html.vue"]]),h=JSON.parse('{"path":"/algorithms/linked-node-reverse.html","title":"链表反转","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"单链表","slug":"单链表","link":"#单链表","children":[]},{"level":2,"title":"相关链接","slug":"相关链接","link":"#相关链接","children":[]}],"git":{},"filePathRelative":"algorithms/linked-node-reverse.md"}');export{v as comp,h as data};
