import{_ as n,c as s,o as a,e}from"./app-0TPXc-ei.js";const p="/assets/img/algorithms/binarytree.jpg",t={},l=e('<h1 id="深度算法" tabindex="-1"><a class="header-anchor" href="#深度算法"><span>深度算法</span></a></h1><div class="custom-container tip"><p class="custom-container-title">说明</p><p><code>深度</code>是从上往下数，也就是从根节点开始往下</p><p><code>高度</code>是从下往上数，就是从某节点往下的最深叶子节点开始往上</p></div><p>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。例如下图中的二叉树的深度为4，因为它从根结点到叶结点最长的路径包含4个结点（从根结点1开始，经过结点2和结点5，最终到达叶结点7）。</p><p><img src="'+p+`" alt="二叉树" title="二叉树"></p><p>定义一个二叉树</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinaryTreeNode</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token return-type class-name">BinaryTreeNode</span> Left <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token keyword">public</span> <span class="token return-type class-name">BinaryTreeNode</span> Right <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h2><ol><li>如果一棵树只有一个结点，它的深度为1。</li><li>如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。</li><li>如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。</li></ol><p>比如在上图的二叉树中，根结点为1的树有左右两个子树，其左右子树的根结点分别为结点2和3。根结点为2的左子树的深度为3，而根结点为3的右子树的深度为2，因此根结点为1的树的深度就是4。</p><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h2><h3 id="递归" tabindex="-1"><a class="header-anchor" href="#递归"><span>递归</span></a></h3><p>使用递归，很容易写出该求解算法，思路也简单，就是左子树和右子树高度，取两者最大，然后在此基础上加1即可</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="line"><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">Depth</span><span class="token punctuation">(</span><span class="token class-name">BinaryTreeNode</span> root<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> node <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">?</span></span>
<span class="line">        <span class="token number">0</span> <span class="token punctuation">:</span></span>
<span class="line">        Math<span class="token punctuation">.</span><span class="token function">Max</span><span class="token punctuation">(</span><span class="token function">Depth</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Depth</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然而，递归使用不当，会有风险，毕竟递归栈的深度非常有限，假如一棵接近线性化的二叉树，也就是严重一侧倾斜，退化成接近一个单链表，当二叉树的深度高达数千甚至上万的时候，使用递归，那是一定会栈溢出的！因此，在栈深度较深乃至于不可控时，我们需要另想办法，取代递归。</p><h3 id="非递归" tabindex="-1"><a class="header-anchor" href="#非递归"><span>非递归</span></a></h3><p>要想实现非递归，那么就不应该考虑左右子树，而是子层级只要有树就加1，然后再循环往下一层级继续判断</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="line"><span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">int</span></span> <span class="token function">Depth</span><span class="token punctuation">(</span><span class="token class-name">BinaryTreeNode</span> node<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment">// 初始化队列</span></span>
<span class="line">    <span class="token class-name"><span class="token keyword">var</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Queue<span class="token punctuation">&lt;</span>BinaryTreeNode<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    queue<span class="token punctuation">.</span><span class="token function">Enqueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token class-name"><span class="token keyword">var</span></span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        len<span class="token operator">++</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment">// 降序解决循环内入队的冲突问题</span></span>
<span class="line">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> queue<span class="token punctuation">.</span>Count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token punctuation">{</span></span>
<span class="line">            <span class="token class-name"><span class="token keyword">var</span></span> child <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">Dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>Left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></span>
<span class="line">                queue<span class="token punctuation">.</span><span class="token function">Enqueue</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>Left<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span>Right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></span>
<span class="line">                queue<span class="token punctuation">.</span><span class="token function">Enqueue</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>Right<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token keyword">return</span> len<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">总结</p><p>队列（Queue）代表了一个先进先出的对象集合。循环降序方式，解决了循环内入队冲突的问题</p></div>`,18),c=[l];function i(o,u){return a(),s("div",null,c)}const d=n(t,[["render",i],["__file","depth.html.vue"]]),k=JSON.parse('{"path":"/algorithms/binarytree/depth.html","title":"深度算法","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"解题思路","slug":"解题思路","link":"#解题思路","children":[]},{"level":2,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[{"level":3,"title":"递归","slug":"递归","link":"#递归","children":[]},{"level":3,"title":"非递归","slug":"非递归","link":"#非递归","children":[]}]}],"git":{},"filePathRelative":"algorithms/binarytree/depth.md"}');export{d as comp,k as data};
